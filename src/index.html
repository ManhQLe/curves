<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Curves</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="content/css/main.css" />
    <script src="content/glmatrix/gl-matrix-min.js"></script>
    <script src="content/d3/d3.min.js"></script>
    <script src="content/js/curve.js"></script>
    <script src="content/js/geo.js"></script>
</head>

<body>
    <div class="topbar">
        <ul>
            <li>
                <input name="operation" checked id="vector" type="radio" /><label for="vector">Vector</label>
            </li>
            <li>
                <input name="operation" id="conduit" type="radio" /><label for="conduit">Conduit</label>
            </li>
            <li>
                <input name="operation" id="bconduit" type="radio" /><label for="select">B-Conduit</label>
            </li>
            <li>
                <input name="operation" id="select" type="radio" /><label for="select">Select</label>
            </li>            
        </ul>
    </div>
    <svg id="main-canvas">
    </svg>

    <script>
        let canvas = document.getElementById("main-canvas");
        let Vessels = [];

        function getOp() {
            for (let x of document.getElementsByName("operation")) {
                if (x.checked)
                    return x.id;
            }
        }


        function renderPathOpt(ps) {
            let b = ToBezierOptimize(ps, .5)
            path.attr("d", optimizePathFromData(b));
        }

        function renderPath(ps) {
            let b = ToBezier(ps, .5)
            let d = [];
            for (let i = 0; i < b.length; i += 4) {
                let b1 = b[i];
                let b2 = b[i + 1];
                let b3 = b[i + 2];
                let b4 = b[i + 3];
                d.push(`M ${b1[0]} ${b1[1]}C${b2[0]} ${b2[1]}, ${b3[0]} ${b3[1]}, ${b4[0]} ${b4[1]}`)
            }

            path.attr("d", d.join(""))
        }

        let circle = null;
        let pointCurve = null;
        let track = {

        }
        let m1;
        let m2;
        let anchor;
        let ghost;
        d3.select(canvas).on("mousedown", (e = d3.event) => {
            track.m1 = track.origin = [e.clientX, e.clientY]
        })

        d3.select(canvas).on("mouseup", (e = d3.event) => {
            anchor ? (Vessels.push(anchor), anchor = null) : 1;
        })

        d3.select(canvas).on("mousemove", (e = d3.event) => {
            if (e.buttons === 1) {
                track.end = track.m2 = [e.clientX, e.clientY]
                let dv = [0, 0]
                vec2.sub(dv, track.m2, track.m1);
                let op = getOp();
                let closeVec;
                switch (op) {
                    case "select":
                        Vessels.forEach(v=>{
  
                            switch(v.constructor.name){
                                case "BCurve":
                                    break;
                                case "Vec":
                                    break;
                            }
                        })
                        break;
                    case "vector":
                        anchor || (anchor = new Vec({
                            P1: track.origin,
                            P2: track.m2,
                            reality: canvas
                        }));
                        anchor.P2 = track.m2;
                        anchor.refresh()

                        break;
                    case "conduit":
                        if (!anchor) {                            
                            closeVec = Vessels.find(x => vec2.dist(x.P2, track.origin) <= 5);
         
                            if (closeVec) {
                                let t1 = [0, 0]
                                vec2.sub(t1, closeVec.P2, closeVec.P1)
                                anchor = new Curve({
                                    P1: closeVec.P2,
                                    T1: t1,
                                    reality:canvas
                                })
                            }

                        } else {                          
                            closeVec = Vessels.find(x => vec2.dist(x.P2, track.m2) <= 5);
                            let p2,t2 = [0,0],t1=[0,0];
                            if(closeVec){
                                p2 = closeVec.P2;
                                t2 = vec2.sub(t2,closeVec.P1,closeVec.P2);
                            }
                            else
                            {
                                p2 = track.m2;
                                t2 = vec2.sub(t2,track.m2, track.origin);
                            }                            
                            
                            anchor.P2 = p2;

                            let dist = vec2.dist(anchor.P2,anchor.P1)
                            dist = Math.max(1,dist)*.5;
                            vec2.normalize(t2,t2);
                            vec2.scale(t2,t2,dist);
                            anchor.T2 = t2;
                            
                            vec2.normalize(t1,anchor.T1);                                                        
                            vec2.scale(t1,t1,dist);      
                            
                            anchor.T1 = t1;                            
                            anchor.refresh();
                            
                        }
                        break;
                    case "bconduit":
                    
                        if (!anchor) {                            
                            closeVec = Vessels.find(x => x.constructor.name==="Vec" && vec2.dist(x.P2, track.origin) <= 5);
         
                            if (closeVec) {
                                let t1 = [0, 0]
                                vec2.sub(t1, closeVec.P2, closeVec.P1)
                                anchor = new BCurve({
                                    P1: closeVec.P2,
                                    T1: t1,
                                    reality:canvas
                                })
                            }

                        } else {                          
                            closeVec = Vessels.find(x =>  x.constructor.name==="Vec" && vec2.dist(x.P2, track.m2) <= 5);
                            let p2,t2 = [0,0],t1=[0,0];
                            if(closeVec){
                                p2 = closeVec.P2;
                                t2 = vec2.sub(t2,closeVec.P2,closeVec.P1);
                            }
                            else
                            {
                                p2 = track.m2;
                                t2 = vec2.sub(t2, track.origin,track.m2);
                            }                            
                            
                            anchor.P2 = p2;

                            let dist = vec2.dist(anchor.P2,anchor.P1)
                            dist = Math.max(1,dist)*.2;
                            vec2.normalize(t2,t2);
                            vec2.scale(t2,t2,dist);
                            anchor.T2 = t2;
                            
                            vec2.normalize(t1,anchor.T1);                                                        
                            vec2.scale(t1,t1,dist);      
                            
                            anchor.T1 = t1;                            
                            anchor.refresh();
                            
                            let M1 = [0,0],M2 = [0,0]
                            vec2.add(M1,anchor.P1,anchor.T1)
                            vec2.add(M2,anchor.P2,anchor.T2)

                            let b = findBoundingBox(anchor.P1,M1,M2,anchor.P2)
                            ghost || (
                                ghost =  d3.select(canvas).append("g").append("path")
                                .attr("stroke","#f1c40f")                                
                                .attr("fill","none")
                                .attr("stroke-dasharray","3 3")
                            )
                            let minp = b[0]
                            let maxp = b[1]
                            
                            ghost.attr("d",[
                                "M",minp[0]," ",minp[1],
                                "L",maxp[0]," ",minp[1],                                
                                "L",maxp[0]," ",maxp[1],
                                "L",minp[0]," ",maxp[1],"Z"
                            ].join(""))

                            
                        }
                        break;
                }

                track.m1 = track.m2;
            }
        })
    </script>
</body>

</html>