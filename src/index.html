<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Curves</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="content/css/main.css" />
    <script src="content/glmatrix/gl-matrix-min.js"></script>
    <script src="content/d3/d3.min.js"></script>
    <script src="content/js/curve.js"></script>
    <script src="content/js/geo.js"></script>
</head>

<body>
    <div class="topbar">
        <ul>
            <li>
                <input name="operation" checked id="vector" type="radio" /><label for="vector">Vector</label>
            </li>
            <li>
                <input name="operation" id="conduit" type="radio" /><label for="conduit">Conduit</label>
            </li>
            <li>
                <input name="operation" id="bconduit" type="radio" /><label for="select">B-Conduit</label>
            </li>
            <li>
                <input name="operation" id="select" type="radio" /><label for="select">Select</label>
            </li>            
        </ul>
    </div>
    <svg id="main-canvas">
    </svg>

    <script>
        let canvas = document.getElementById("main-canvas");
        let Vecs = [];
        let p1 = [10, 20]
        let p2 = [100, 200]
        let p3 = [340, 270]
        let p4 = [550, 100]
        let ctrlPoints = [p1, p2, p3, p4];



        let g = d3.select(canvas).append("g");


        let path = g.append("path")
        path.attr("stroke", "#3498db")

        g.selectAll("circle")
            .data(ctrlPoints)
            .enter()
            .append("circle")
            .attr("type", "ctrl")
            .attr("cx", function (d) {
                return d[0]
            })
            .attr("cy", function (d) {
                return d[1]
            })
            .attr("r", 5)
            .attr('stroke-width', 2)
            .attr("stroke", "white")
            .attr("fill", "#e74c3c")

        function getOp() {
            for (let x of document.getElementsByName("operation")) {
                if (x.checked)
                    return x.id;
            }
        }



        function renderPathOpt(ps) {
            let b = ToBezierOptimize(ps, .5)
            path.attr("d", optimizePathFromData(b));
        }

        function renderPath(ps) {
            let b = ToBezier(ps, .5)
            let d = [];
            for (let i = 0; i < b.length; i += 4) {
                let b1 = b[i];
                let b2 = b[i + 1];
                let b3 = b[i + 2];
                let b4 = b[i + 3];
                d.push(`M ${b1[0]} ${b1[1]}C${b2[0]} ${b2[1]}, ${b3[0]} ${b3[1]}, ${b4[0]} ${b4[1]}`)
            }

            path.attr("d", d.join(""))
        }

        let circle = null;
        let pointCurve = null;
        let track = {

        }
        let m1;
        let m2;
        let anchor;
        d3.select(canvas).on("mousedown", (e = d3.event) => {
            track.m1 = track.origin = [e.clientX, e.clientY]
        })

        d3.select(canvas).on("mouseup", (e = d3.event) => {
            anchor ? (Vecs.push(anchor), anchor = null) : 1;
        })

        d3.select(canvas).on("mousemove", (e = d3.event) => {
            if (e.buttons === 1) {
                track.end = track.m2 = [e.clientX, e.clientY]
                let dv = [0, 0]
                vec2.sub(dv, track.m2, track.m1);
                let op = getOp();
                switch (op) {
                    case "select":
                        anchor || (anchor = ctrlPoints.find(p => {
                            return vec2.dist(p, track.origin) <= 5;
                        }))
                        if (anchor) {
                            anchor[0] = track.m2[0];
                            anchor[1] = track.m2[1];

                            g.selectAll("circle")
                                .attr("cx", function (d) {
                                    return d[0]
                                })
                                .attr("cy", function (d) {
                                    return d[1]
                                })
                            renderPathOpt(ctrlPoints);
                        }
                        break;
                    case "vector":
                        anchor || (anchor = new Vec({
                            P1: track.origin,
                            P2: track.m2,
                            reality: canvas
                        }));
                        anchor.P2 = track.m2;
                        anchor.refresh()

                        break;
                    case "conduit":
                        let closeVec;
                        if (!anchor) {                            
                            closeVec = Vecs.find(x => vec2.dist(x.P2, track.origin) <= 5);
         
                            if (closeVec) {
                                let t1 = [0, 0]
                                vec2.sub(t1, closeVec.P2, closeVec.P1)
                                anchor = new Curve({
                                    P1: closeVec.P2,
                                    T1: t1,
                                    reality:canvas
                                })
                            }

                        } else {                          
                            closeVec = Vecs.find(x => vec2.dist(x.P2, track.m2) <= 5);
                            let p2,t2 = [0,0],t1=[0,0];
                            if(closeVec){
                                p2 = closeVec.P2;
                                t2 = vec2.sub(t2,closeVec.P1,closeVec.P2);
                            }
                            else
                            {
                                p2 = track.m2;
                                t2 = vec2.sub(t2,track.m2, track.origin);
                            }                            
                            
                            anchor.P2 = p2;

                            let dist = vec2.dist(anchor.P2,anchor.P1)
                            dist = Math.max(1,dist)*.5;
                            vec2.normalize(t2,t2);
                            vec2.scale(t2,t2,dist);
                            anchor.T2 = t2;
                            
                            vec2.normalize(t1,anchor.T1);                                                        
                            vec2.scale(t1,t1,dist);      
                            
                            anchor.T1 = t1;                            
                            anchor.refresh();
                            
                        }
                        break;
                    case "bconduit":
                        break;
                }


                //Create Conduit
                // let path = pointCurve.path || g.append("path")
                //     .attr("stroke", "#9b59b6").attr("stroke-width", 2)
                //     .attr("fill", "none")
                // pointCurve.P2 = m;
                // let T1 = [0, 0]
                // vec2.sub(T1, pointCurve.P2, pointCurve.P1);
                // let projLen = vec2.dot([1, 0], T1);
                // vec2.scale(T1, [1,0], projLen);
                // let b = Hermite2Bezier(pointCurve.P1,T1,pointCurve.P2,T1);
                // path.attr("d", optimizePathFromData(b))
                // pointCurve.path = path;

                track.m1 = track.m2;
            }
        })
        renderPathOpt(ctrlPoints)
    </script>
</body>

</html>