<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Curves</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" media="screen" href="content/css/main.css" />
    <script src="content/glmatrix/gl-matrix-min.js"></script>
    <script src="content/d3/d3.min.js"></script>
    <script src="content/js/curve.js"></script>
    <script src="content/js/geo.js"></script>
</head>

<body>
    <div class="topbar">
        <ul>
            <li>
                <input name="operation" checked id="vec" type="radio"/><label for="vec">Vector</label>
            </li>
            <li>
                <input name="operation" id="conduit" type="radio"/><label for="conduit">Conduit</label>
            </li>
            <li>
                <input name="operation" id="select" type="radio"/><label for="select">Select</label>
            </li>
        </ul>
    </div>
    <svg id="main-canvas">
    </svg>

    <script>
       
        let canvas = document.getElementById("main-canvas");
        let p1 = [10, 20]
        let p2 = [100, 200]
        let p3 = [340, 270]
        let p4 = [550, 100]
        let ctrlPoints = [p1, p2, p3, p4];

        let track = [0, 0]


        let g = d3.select(canvas).append("g");


        let path = g.append("path")
        path.attr("stroke", "#3498db")

        g.selectAll("circle")
            .data(ctrlPoints)
            .enter()
            .append("circle")
            .attr("cx", function (d) { return d[0] })
            .attr("cy", function (d) { return d[1] })
            .attr("r", 5)
            .attr('stroke-width', 2)
            .attr("stroke", "white")
            .attr("fill", "#e74c3c")

        function operationPathFromData(b) {
            let d = [];
            let b1 = b[0];
            d.push(`M ${b1[0]} ${b1[1]}`)
            for (let i = 1; i < b.length; i += 3) {
                let b1 = b[i];
                let b2 = b[i + 1];
                let b3 = b[i + 2];
                d.push(`C${b1[0]} ${b1[1]}, ${b2[0]} ${b2[1]}, ${b3[0]} ${b3[1]}`)
            }
            return d.join("")
        }

        function renderPathOpt(ps) {
            let b = ToBezierOptimize(ps, .5)
            path.attr("d", operationPathFromData(b));
        }

        function renderPath(ps) {
            let b = ToBezier(ps, .5)
            let d = [];
            for (let i = 0; i < b.length; i += 4) {
                let b1 = b[i];
                let b2 = b[i + 1];
                let b3 = b[i + 2];
                let b4 = b[i + 3];
                d.push(`M ${b1[0]} ${b1[1]}C${b2[0]} ${b2[1]}, ${b3[0]} ${b3[1]}, ${b4[0]} ${b4[1]}`)
            }

            path.attr("d", d.join(""))
        }

        let circle = null;
        let pointCurve = null;

        d3.select(canvas).on("mousedown", (e = d3.event) => {
            if (e.target.tagName === "circle")
                circle = e.target;
            else {
                pointCurve = new ThreePointCurve([e.clientX, e.clientY],
                    [e.clientX, e.clientY]
                );
            }
            track = [e.clientX, e.clientY]
        })

        d3.select(canvas).on("mouseup", (e = d3.event) => {
            circle = null;
            pointCurve = null;
        })

        d3.select(canvas).on("mousemove", (e = d3.event) => {
            if (e.buttons === 1) {
                let m = [e.clientX, e.clientY]
                let dv = [m[0] - track[0], m[1] - track[1]]
                if (circle) {
                    let d = d3.select(circle).datum()
                    d[0] += dv[0];
                    d[1] += dv[1];
                    d3.select(circle)
                        .attr("cx", d[0])
                        .attr("cy", d[1])
                    renderPathOpt(ctrlPoints)
                }
                else if (pointCurve) {
                    let path = pointCurve.path || g.append("path")
                        .attr("stroke", "#9b59b6").attr("stroke-width", 2)
                        .attr("fill", "none")
                    pointCurve.P2 = m;
                    let T1 = [0, 0]
                    vec2.sub(T1, pointCurve.P2, pointCurve.P1);
                    let projLen = vec2.dot([1, 0], T1);
                    vec2.scale(T1, [1,0], projLen);
                    let b = Hermite2Bezier(pointCurve.P1,T1,pointCurve.P2,T1);
                    path.attr("d", operationPathFromData(b))
                    pointCurve.path = path;
                }
                track = m;
            }

        })
        renderPathOpt(ctrlPoints)

    </script>
</body>

</html>